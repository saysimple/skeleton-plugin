'use strict';

var fs = require('fs');
var path = require('path');
var rollupPluginutils = require('rollup-pluginutils');

const crypto = require('crypto');

const defaultExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.svg'];

const getHash = content => {
	try {
		const hashFunc = crypto.createHash('md5');
		return hashFunc.update(content).digest('hex');
	} catch (e) {
		return null;
	}
};

const generateFileNameWithHash = (basename, extname, hash) => {
	return `${basename}_${hash}.${extname}`.replace('..', '.');
};

function image(options = {}) {
	const extensions = options.extensions || defaultExtensions;
	const includes = extensions.map(e => `**/*${e}`);
	const filter = rollupPluginutils.createFilter(options.include || includes, options.exclude);
	let images = new Map();

	function generateBundle(outputOptions, rendered) {
		const dir =
			options.output ||
			outputOptions.dir ||
			path.dirname(outputOptions.dest || outputOptions.file);
		if (!fs.existsSync(dir)) {
			fs.mkdirSync(dir, { recursive: true });
		}
		for (const [image, hash] of images) {
			const ext = path.extname(image);
			fs.writeFileSync(
				`${dir}/${generateFileNameWithHash(path.basename(image, ext), ext, hash)}`,
				fs.readFileSync(image)
			);
		}
	}

	return {
		name: 'image-assets',
		load(image) {
			if ('string' !== typeof image || !filter(image)) {
				return null;
			}

			if (!images.has(image)) {
				const content = fs.readFileSync(image);
				const hash = getHash(content);
				images.set(image, hash);
			}

			const hash = images.get(image);
			const ext = path.extname(image);
			return `const img = require('${
				options.output ? options.output : '.'
			}/${generateFileNameWithHash(
				path.basename(image, ext),
				ext,
				hash
			)}').default; export default img;`;
		},
		generateBundle,
		ongenerate: generateBundle
	};
}

module.exports = image;
